---
title: "&nbsp;"
fig_width: 5
fig_height: 5
params:
  output_zip: NA
  spectrum_file: NA
  options: NA
output:
  html_document:
    includes:
      in_header: header.html
    anchor_sections: false
---

``` {css, echo = FALSE}

.main-container {
max-width: 1300px;
margin-left: 0;
margin-right: 1;
text-align: justify;
text-justify: inter-word;
}

.banner {
 background-color: #b5132c;
  font-weight: 200;
  position: relative;
  padding: .5rem 1rem;
  display: flex;
max-width: 1300px;

}

.logo_naomi {
 height: 60px;
 padding-left: 15px;
 padding-right: 10px;
}

.logo_unaids {
   height: 60px;
}

.text {
 padding-left: 10px;
 padding-top: 10px;
 color: white;
font-size: 35px;

}

```


```{r read_outputs, echo=FALSE, message = FALSE, warning = FALSE}
# Read in files from naomi outputs zip
output_zip <- params$output_zip

outputs <- naomi::read_output_package(output_zip)
inputs <- unz(output_zip, "info/inputs.csv") 
inputs <- read.csv(inputs)
options <- unz(output_zip, "info/options.yml")
options <- yaml::read_yaml(options)

indicators <- naomi::add_output_labels(outputs) %>%
  dplyr::left_join(
           outputs$meta_area %>%
           dplyr::select(area_level, area_id, center_x, center_y), 
           by = c("area_level", "area_id")
         ) %>%
  sf::st_as_sf()

# Grab inputs and model options from model output zip file
# # concatenating strings where more than one option may be selected
report_date <- format(Sys.Date(), "%B %d, %Y")
t1 <- options$calendar_quarter_t1
t2 <- options$calendar_quarter_t2
iso <- options$area_scope
quarter_t1 <- outputs$meta_period[outputs$meta_period$calendar_quarter == t1,]$quarter_label
quarter_t2 <- outputs$meta_period[outputs$meta_period$calendar_quarter == t2,]$quarter_label
level <- as.integer(options$area_level)
survey_prev <- paste0(options$survey_prevalence, collapse = ", ")
survey_art <- paste0(options$survey_art_coverage, collapse = ", ")
survey_recent <- paste0(options$survey_recently_infected, collapse = ", ")
spectrum_file <- paste0(inputs[inputs$role == "pjnz",]$filename)


# Determine if and when programme data has been included 
include <- tibble::tibble(
  art = list(options$include_art_t1, options$include_art_t2),
  art_year = list(quarter_t1, quarter_t2),
  art_attend = list(options$artattend, options$artattend_t2),
  anc_art = list(options$anc_art_coverage_year1, options$anc_art_coverage_year2),
  anc_prev = list(options$anc_prevalence_year1,options$anc_prevalence_year2)
) %>%
  dplyr::mutate_all(list(~na_if(., "NULL"))) %>%
  dplyr::mutate_all(list(~na_if(., "")))

# Select years where ART programme data is included

if("true" %in% include$art) {
  df <- include %>% dplyr::filter(art == "true")
  art_year <- paste0(df$art_year, sep = "", collapse = " and ")
} else {
  art_year <- NA
}

# Select years where ART attendance reallocation is implemented
if("true" %in% include$art_attend ) {
  df <- include %>% dplyr::filter(art_attend == "true")
  art_attend <- paste0(df$art_year, sep = "", collapse = " and ")
} else {
  art_attend <- NA
}

# Select years where ANC ART programme data is included
if(sum(length(is.na(include$anc_art))) < 2) {
  df <- include %>% dplyr::filter(anc_art != "NULL")
  anc_art <- paste0(df$anc_art, sep = "", collapse = " and ")
} else {
  anc_art <- NA
}

# Select years where ANC prev programme data is included
if(sum(length(is.na(include$anc_prev))) < 2) {
  df <- include %>% dplyr::filter(anc_prev != "NULL")
  anc_prev <- paste0(df$anc_prev, sep = "", collapse = " and ")
} else {
  anc_prev <- NA
}


# Identify area_level_label for model estimates
area_level_map <- outputs$meta_area %>%
  dplyr::group_by(area_level, area_level_label) %>%
  dplyr::summarise(.groups = "drop")

area_level_label <- area_level_map$area_level_label[area_level_map$area_level == level]
country <- paste0(outputs$meta_area$area_name[outputs$meta_area$area_id == iso],
                  sep = "", collapse = "")


# Filter data for area + calendar options selected in model run 
data <- dplyr::filter(indicators, 
                      area_level == level, 
                      calendar_quarter == t2)

# Determine number of districts in lowest area level
district_count <- length(levels(as.factor(data$area_name)))

# Legend functions
#-------------------------------------------------------------------------------
# Map Figure
#-------------------------------------------------------------------------------
map_outputs <- function(geom_data,
                        var,
                        age, 
                        sex,
                        start_colour_scale, 
                        end_colour_scale, 
                        legend_title, 
                        legend_label = ggplot2::waiver(), 
                        fig_title) {
  
  # filter data for desired indicator
  fig_data <- geom_data %>% dplyr::filter(indicator == var, 
                                          age_group == age,
                                          sex == sex)
  # generate figure
  ggplot2::ggplot(fig_data, ggplot2::aes(fill = mean)) +
    ggplot2::geom_sf() +
    ggplot2::coord_sf(datum = NA) +
    ggplot2::scale_fill_gradient(low = start_colour_scale,
                                 high = end_colour_scale,
                                 name = legend_title,
                                 guide = "legend", 
                                 labels = legend_label) +
    ggplot2::theme_bw() +
    ggplot2::theme(legend.position = "bottom",
                   legend.direction = "vertical", 
                   plot.title = ggplot2::element_text(size = 8, face = "bold"), 
                   legend.text = ggplot2::element_text(size = 8), 
                   legend.title = ggplot2::element_text(size = 8, face = "bold", hjust = 0.5),
                   legend.key.size = ggplot2::unit(0.7, "lines"),
                   legend.background = ggplot2::element_rect(linetype = "dashed",
                                                             colour = "black"),
                   legend.title.align = 0.5, 
                   plot.margin = ggplot2::margin(0, 0.4, 0, 0.4, "cm")) +
    ggplot2::ggtitle(fig_title)
}

#-------------------------------------------------------------------------------
# Pop pyramid
#-------------------------------------------------------------------------------
pop_pyramid_outputs <- function(disag_data,
                                var,
                                left_colour, 
                                right_colour, 
                                x_axis_title, 
                                legend_label = abs, 
                                fig_title) {

  ## filter data for desired indicator
  fig_data <- disag_data %>% dplyr::filter(indicator == var) 
  
  plot <- ggplot2::ggplot(fig_data, ggplot2::aes(x = ifelse(sex == "male", -mean, mean),
                                                 y = age_group,
                                                 ymin = lower,
                                                 ymax = upper,
                                                 fill = sex)) +
    ggplot2::geom_col(width = 0.85) +
    ggplot2::scale_x_continuous(labels = legend_label,
                                limits = max(fig_data$mean) * c(-1,1)) +
    ggplot2::labs(x = x_axis_title) +
    ggplot2::scale_fill_manual(values = c("male" = left_colour, "female" = right_colour)) +
    ggplot2::theme_classic(base_size = 10) +
    ggplot2::theme(legend.position = "top", 
                   plot.title = ggplot2::element_text(size = 8, face = "bold",
                                             hjust = 0.5),
                   axis.title = ggplot2::element_text(size = 6), 
                   axis.text.x = ggplot2::element_text(size = 5),
                   axis.text.y = ggplot2::element_text(size = 5),
                   legend.title = ggplot2::element_blank(),
                   legend.text = ggplot2::element_text(size = 6), 
                   legend.key.size = ggplot2::unit(0.5, "lines"),
                   plot.margin = ggplot2::margin(0.5, 0.3, 0.5, 0.3, "cm")) +
    ggplot2::ylab("Age Group") +
    ggplot2::ggtitle(fig_title)
}

#-------------------------------------------------------------------------------
# District Barplot + National indicator
#-------------------------------------------------------------------------------
  
 national_district_bar_plot <- function(district_data, 
                               var, 
                               age_disag, 
                               sex_disag = "both",
                               national_indicator,
                               label_format,
                               x_axis_title, 
                               fig_title) {
   
   # Filter data for desired indicator and disag
   # # assign categories based on national level indicator 
   fig_data <- data %>% sf::st_drop_geometry() %>%
     dplyr::filter(indicator == var, 
                   age_group == age_disag,
                   sex == sex_disag, 
     )%>%
     dplyr::mutate(threshold = ifelse(mean > national_indicator,"above", "below"),
                   threshold = as.factor(threshold))
   
   #Plot figure
   ggplot2::ggplot(fig_data, ggplot2::aes(reorder(area_name, mean),
                                                mean,
                                                ymin = lower,
                                                ymax = upper,
                                                fill = threshold)) +
     ggplot2::theme_classic() +
     ggplot2::geom_col(position = "dodge") +
     ggplot2::geom_linerange(position = ggplot2::position_dodge(0.8)) +
     ggplot2::scale_y_continuous(labels = label_format) +
     ggplot2::theme(
       axis.text.x = ggplot2::element_text(size = 8),
       legend.background = ggplot2::element_rect(linetype = "dashed", colour = "black"),
       legend.text = ggplot2::element_text(size = 8), 
       legend.position = "bottom",
       legend.direction = "vertical", 
       legend.title = ggplot2::element_text(size = 8, face = "bold"), 
       axis.title.x = ggplot2::element_text(size = 8, face = "bold"), 
       axis.title.y = ggplot2::element_blank()) +
     ggplot2::ylab(x_axis_title) +
     ggplot2::geom_hline(yintercept= national_indicator, linetype="dashed", color = "black")+
     
     ggplot2::ggtitle(fig_title) + 
     ggplot2::coord_flip()
   
 }

#------------------------------------------------------------------------------- 
# District Barplot (no national indicator)
#-------------------------------------------------------------------------------  
district_bar_plot <- function(district_data, 
                               var, 
                               age_disag, 
                              colour,
                               sex_disag = "both",
                              label_format,
                               x_axis_title, 
                               fig_title) {
   
   # Filter data for desired indicator and disag
   # # assign categories based on national level indicator 
   fig_data <- data %>% sf::st_drop_geometry() %>%
     dplyr::filter(indicator == var, 
                   age_group == age_disag,
                   sex == sex_disag)
   
   #Plot figure
   ggplot2::ggplot(fig_data, ggplot2::aes(reorder(area_name, mean),
                                                mean,
                                                ymin = lower,
                                                ymax = upper)) +
     ggplot2::theme_classic() +
     ggplot2::geom_col(position = "dodge", fill = colour) +
     ggplot2::geom_linerange(position = ggplot2::position_dodge(0.8)) +
     ggplot2::scale_y_continuous(labels = label_format) +
     ggplot2::theme(
       axis.text.x = ggplot2::element_text(size = 8),
       axis.title.x = ggplot2::element_text(size = 8, face = "bold"), 
       axis.title.y = ggplot2::element_blank()) +
     ggplot2::ylab(x_axis_title) +
     ggplot2::ggtitle(fig_title) + 
     ggplot2::coord_flip()
   
 }
 
```

```{r, echo = FALSE, results = 'asis'}

cat(paste0("# ", country, " Subnational HIV Estimates \n"))

cat(paste0("### **", quarter_t2, "** (report ", report_date, ")"))
```

``` {r, echo = FALSE, results = 'asis'}
cat(paste0("This report summarises the **", area_level_label, "-level** HIV indicators for **", country,"** from the Naomi model", sep = "\n"))
```

Naomi is a statistical model that uses data from several sources, including:  

National survey data:   

```{r, echo = FALSE, results = 'asis'}
text1 <- tibble::tibble(prefix = c("National household survey data on new HIV infections from ",
                                   "National household survey data on HIV prevalence from ",
                                   "National household survey data on ART coverage from "), 
                        source = c(survey_recent,
                                   survey_prev,
                                   survey_art)) %>%
  dplyr::filter(source != "")


cat(paste0("* ", text1$prefix, "_", text1$source, "_"), sep = "\n")
```
  
Operational programme data:  
  
```{r, echo = FALSE, results= 'asis'}
programme_data <- c(art_year, anc_prev, anc_art)

if(sum(is.na(programme_data))<3) {
  
  cat(paste0("\n Operational programme data: \n", sep = "\n"))
  
  text2 <- tibble::tibble(prefix = c("National programme data on ART coverage for ",
                                  "National programme data on ANC HIV prevalence for ", 
                                  "National programme data on ANC ART coverage for "
                                  ), 
                       source = c(art_year,
                                  anc_prev, 
                                  anc_art)) %>%
  tidyr::drop_na()


cat(paste0("\n ",cat(paste0("* ", text2$prefix, "_", text2$source, "_"), sep = "\n")))
  
}

 cat(paste0("\n and national HIV estimates from Spectrum file _", spectrum_file,"_",
           "\n using calibration options: \n " ))
```
```{r, echo = FALSE, results = 'asis'}

# Translate calibration options to human readable
calibration_options <- options[grep("calibration", names(options))]
calibration_options <- get_calibration_option_labels(calibration_options)

text <- tibble::tibble(prefix = c("Population calibration: ",
                                  "PLHIV calibration level: ", 
                                  "PLHIV calibration strata: ", 
                                  "ART number calibration level: ", 
                                  "ART number calibration strata: ", 
                                  "New infections calibration strata: "), 
                       source = c(calibration_options$spectrum_population_calibration,
                                  calibration_options$spectrum_plhiv_calibration_level,
                                  calibration_options$spectrum_plhiv_calibration_strat,
                                  calibration_options$spectrum_artnum_calibration_level,
                                  calibration_options$spectrum_artnum_calibration_strat, 
                                  calibration_options$spectrum_infections_calibration_strat))

cat(paste0("* ", text$prefix, "_", text$source, "_"), sep = "\n")

```

```{r, echo = FALSE, results = 'asis'}
if("true" %in% include$art_attend) {
  
  cat(paste0("ART coverage is estimated accounting for patient mobility between
             neighbouring districts (for ", art_attend, "). 
             \n Further technical information about this allocation method
             and the Naomi model is available at the end of this report."))
} else {
  
  cat(paste0("Further technical information about the Naomi model is available 
             at the end of this report."))
}

```


### **Geographic distribution of PLHIV**

```{r, echo=FALSE,warning = FALSE, out.width  =  "75%", results = 'asis' }

#-------------------------------------------------------------------------------
# Map: PLHIV (mean)
# # By lowest area_level
#-------------------------------------------------------------------------------
p1 <- map_outputs(geom_data = data, 
                  var = "plhiv",
                  age = "Y015_049", 
                  sex = "both", 
                  start_colour_scale = "white", 
                  end_colour_scale = "red4", 
                  fig_title = "People living with HIV (15-49)",
                  legend_title = "PLHIV")
#-------------------------------------------------------------------------------
# Map: on ART
# # By lowest area_level
#-------------------------------------------------------------------------------
p2 <- map_outputs(geom_data = data, 
                  var = "art_current_residents",
                  age = "Y015_999", 
                  sex = "both", 
                  start_colour_scale = "white", 
                  end_colour_scale = "olivedrab4", 
                  fig_title = "Residents receiving ART (15+)",
                  legend_title = "Number on ART"
)

#-------------------------------------------------------------------------------
# Map: new infections (mean)
# # By lowest area_level
#-------------------------------------------------------------------------------
p3 <- map_outputs(geom_data = data, 
                  var = "infections",
                  age = "Y015_049", 
                  sex = "both", 
                  start_colour_scale = "white", 
                  end_colour_scale = "skyblue4", 
                  fig_title = "Annual HIV infections (15-49)",
                  legend_title = "Infections" )


grid::grid.draw(cbind(ggplot2::ggplotGrob(p1), ggplot2::ggplotGrob(p2), 
                      ggplot2::ggplotGrob(p3)))

```

### **Geographic distribution of rates of HIV infection**

```{r, echo=FALSE,warning = FALSE, out.width  =  "75%", out.height=  "100%", results = 'asis' }

#-------------------------------------------------------------------------------
# Map: PLHIV (mean)
# # By lowest area_level
#-------------------------------------------------------------------------------
p4 <- map_outputs(geom_data = data, 
                  var = "prevalence",
                  age = "Y015_049", 
                  sex = "both", 
                  start_colour_scale = "white", 
                  end_colour_scale = "red4", 
                  fig_title = "HIV prevalence (15-49)",
                  legend_title = "Prevalence", 
                  legend_label = scales::percent_format())

#-------------------------------------------------------------------------------
# Map: new infections (mean)
# # By lowest area_level
#-------------------------------------------------------------------------------
p5 <- map_outputs(geom_data = data, 
                  var = "art_coverage",
                  age = "Y015_999", 
                  sex = "both", 
                  start_colour_scale = "white", 
                  end_colour_scale = "olivedrab4", 
                  fig_title = "Proportion PLHIV on ART (15+)",
                  legend_title = "ART Coverage", 
                  legend_label = scales::percent_format()
)

#-------------------------------------------------------------------------------
# Map: on ART
# # By lowest area_level
#-------------------------------------------------------------------------------
p6 <- map_outputs(geom_data = data, 
                  var = "incidence",
                  age = "Y015_049", 
                  sex = "both", 
                  start_colour_scale = "white", 
                  end_colour_scale = "skyblue4", 
                  fig_title = "Rate of HIV infection (15-49)",
                  legend_title = "Incidence per 1000", 
                  legend_label = scales::label_number(0.01, 1000)
)

grid::grid.draw(cbind(ggplot2::ggplotGrob(p4), ggplot2::ggplotGrob(p5), 
                      ggplot2::ggplotGrob(p6)))

```

### **Distribution of HIV by age and sex**

```{r, echo = FALSE, warning = FALSE, message= FALSE, out.width = "75%", fig.height = 3, fig.width = 6}

area_levels <- levels(as.factor(indicators$area_level))

if("0" %in% area_levels){
  area_filter = 0
} else {
  area_filter = min(indicators$area_level)
} 

age_sex <- indicators %>%
  sf::st_drop_geometry() %>%
  dplyr::left_join(outputs$meta_age_group, by = c("age_group", "age_group_label")) %>%
  dplyr::filter(area_level == area_filter,
                calendar_quarter == t2,
                sex != "both",
                age_group_span == 5) %>%
  dplyr::mutate(
           age_group = forcats::fct_reorder(age_group_label, age_group_sort_order),
           sex = factor(sex, levels = c("male", "female"))
         )


#-------------------------------------------------------------------------------
# Pop Pyramid: PLHIV (mean)
# # By age and sex (15-49)
#-------------------------------------------------------------------------------
p7 <- pop_pyramid_outputs(disag_data = age_sex,
                          var = "plhiv",
                          left_colour = "mistyrose2",
                          right_colour = "red4",
                          x_axis_title = "PLHIV",
                          fig_title = "People living with HIV"
)

#-------------------------------------------------------------------------------
# Pop Pyramid: On ART (mean)
# # By age and sex (15-49)
#-------------------------------------------------------------------------------
p8 <- pop_pyramid_outputs(disag_data = age_sex,
                          var = "art_current_residents",
                          left_colour = "honeydew3",
                          right_colour = "olivedrab4",
                          x_axis_title = "Number on ART",
                          fig_title = "Residents receiving ART"
)


p8 <- p8 + ggplot2::theme(
  axis.title.y = ggplot2::element_blank(),
  axis.text.y = ggplot2::element_blank(),
  axis.ticks.y = ggplot2::element_blank()
)

#-------------------------------------------------------------------------------
# Pop Pyramid: New Infections
# # By age and sex (15-49)
#-------------------------------------------------------------------------------
p9 <- pop_pyramid_outputs(disag_data = age_sex,
                          var = "infections",
                          left_colour = "slategray3",
                          right_colour = "skyblue4",
                          x_axis_title = "Infections",
                          fig_title = "Annual HIV infections"
)

p9 <- p9 + ggplot2::theme(
  axis.title.y = ggplot2::element_blank(),
  axis.text.y = ggplot2::element_blank(),
  axis.ticks.y = ggplot2::element_blank()
)

# Plot figs together
grid::grid.draw(cbind(ggplot2::ggplotGrob(p7), ggplot2::ggplotGrob(p8), 
                      ggplot2::ggplotGrob(p9)))

```

```{r, echo = FALSE, results = 'asis'}
cat(paste0("### **", area_level_label, "-level HIV trends**"))
```

```{r, echo = FALSE}
## Dynamicaly size plot based on number of districts

if(district_count <= 35){height <- 8}
if(district_count > 35 && district_count <= 65){height <- 10}
if(district_count > 65 && district_count <= 125){height <- 14}
if(district_count > 125 && district_count <= 160){height <- 20}
if(district_count > 180){fig_height <- 24}

```

``` {r, echo=FALSE, warning = FALSE, result = "asis", fig.height = height, fig.width = 10}
# Check output data for area levels avalible
## If national level data is present, generate figure comparing district level 
## indicator to national level otherwise generate district level figure


if("0" %in% area_levels) {
  # If national level indicator is present:
  # # define National level indicators
  
  national <- indicators %>% 
    sf::st_drop_geometry() %>%
    dplyr::filter(area_level == 0,
                  sex == "both",
                  age_group == "Y015_049",
                  calendar_quarter == t2)
  
  national_inc <- national[national$indicator == "incidence",]$mean
  national_prev <- national[national$indicator == "prevalence",]$mean
  national_art <- national[national$indicator == "art_coverage",]$mean
  
  #-----------------------------------------------------------------------------
  # Barplot: Preavalence
  # # By lowest area_level, descending, compared to national indicator
  #-----------------------------------------------------------------------------
  p13 <- national_district_bar_plot(district_data = data, 
                                    var = "prevalence", 
                                    age_disag = "Y015_049", 
                                    national_indicator = national_prev, 
                                    label_format = scales::percent_format(1),
                                    x_axis_title = "HIV Prevalence", 
                                    fig_title = "HIV Prevalence (15-49)")
  
  
  p13 <- p13 + ggplot2::scale_fill_manual(name = paste0("National HIV Prevalence: \n ",
                                                        round(national_prev*100, 2),"%"),
                                          values = c("above" = "red4", 
                                                     "below" = "mistyrose2"))
  
  
  #-------------------------------------------------------------------------------
  # Barplot: ART coverage
  # # By lowest area_level, descending, compared to national indicator
  #--------------------------------------------------------------------------------
  
  p14 <- national_district_bar_plot(district_data = data, 
                                    var = "art_coverage", 
                                    age_disag = "Y015_999", 
                                    national_indicator = national_art, 
                                    label_format = scales::percent_format(1),
                                    x_axis_title = "ART_coverage", 
                                    fig_title = "Proportion PLHIV on ART (15+)")
  
  
  p14 <- p14 + ggplot2::scale_fill_manual(name = paste0("National ART Coverage:\n ", 
                                                        round(national_art*100, 2),"%"),
                                          values = c("above" = "olivedrab4",
                                                     "below" = "honeydew3"))
   
  
  #-----------------------------------------------------------------------------
  # Barplot: Incidence per 1000
  # # By lowest area_level, descending, compared to national indicator
  #-----------------------------------------------------------------------------
   
  p15 <- national_district_bar_plot(district_data = data, 
                                    var = "incidence", 
                                    age_disag = "Y015_049", 
                                    national_indicator = national_inc, 
                                    label_format = scales::label_number(0.01, 1000),
                                    x_axis_title = "Rate of HIV infection (15-49)", 
                                    fig_title = "HIV Incidence per 1000 population")
   
   
  p15 <- p15 + ggplot2::scale_fill_manual(name = paste0("National HIV Incidence\n per 1000 population: ",    
                                                         round(national_inc*1000, 2)),
                                               values = c("above" = "skyblue4", 
                                                          "below" = "slategray3")) 
   
  
  # Plot figs together
  bar_plot <- grid::grid.draw(cbind(ggplot2::ggplotGrob(p13), ggplot2::ggplotGrob(p14),
                        ggplot2::ggplotGrob(p15)))
  
} else {
  
  # If no national level indicator is present:
  
  #-----------------------------------------------------------------------------
  # Barplot: Preavalence
  # # By lowest area_level, descending
  #-----------------------------------------------------------------------------
  p13 <- district_bar_plot(district_data = data, 
                           var = "prevalence", 
                           age_disag = "Y015_049", 
                           colour = "red4", 
                           label_format = scales::percent_format(1),
                           x_axis_title = "HIV Prevalence", 
                           fig_title = "HIV Prevalence (15-49)")
  
  #-----------------------------------------------------------------------------
  # Barplot: ART coverage
  # # By lowest area_level, descending
  #-----------------------------------------------------------------------------
  
  p14 <- district_bar_plot(district_data = data, 
                                    var = "art_coverage", 
                                    age_disag = "Y015_999", 
                                    colour = "olivedrab4", 
                                    label_format = scales::percent_format(1),
                                    x_axis_title = "ART_coverage", 
                                    fig_title = "Proportion PLHIV on ART (15+)")
  
  #-----------------------------------------------------------------------------
  # Barplot: Incidence per 1000
  # # By lowest area_level, descending
  #-----------------------------------------------------------------------------
  p15 <- district_bar_plot(district_data = data, 
                                    var = "incidence", 
                                    age_disag = "Y015_049", 
                                    colour = "skyblue4", 
                                    label_format = scales::label_number(0.01, 1000),
                                    x_axis_title = "Rate of HIV infection (15-49)", 
                                    fig_title = "HIV Incidence per 1000 population")
  
  # Plot figs together
  bar_plot <- grid::grid.draw(cbind(ggplot2::ggplotGrob(p13), ggplot2::ggplotGrob(p14),
                        ggplot2::ggplotGrob(p15)))
  
}

```


```{r, echo = FALSE, results = 'asis'}
cat(paste0("### **", area_level_label, "-level indicators**"))
```

``` {r summary_table, echo = FALSE, warning = FALSE, results = 'asis'}


# # Format data for table
percent_indicators <- c("prevalence", "art_coverage")
whole_indicators <- c("plhiv", "infections", "art_current", "art_current_residents")

## Scaling factor
display_scale <- c("prevalence" = 100,
                   "art_coverage" = 100,
                   "incidence" = 1000,
                   "plhiv" = 1,
                   "infections" = 1,
                   "art_current" = 1,
                   "art_current_residents" = 1)
                   
## Number of digits to round by; applied after scaling.
display_digits <- c("prevalence" = 1,
                    "art_coverage" = 1,
                    "incidence" = 1,
                    "plhiv" = -2,
                    "infections" = -1,
                    "art_current" = -2,
                    "art_current_residents" = -2)

display_suffix <- c("prevalence" = "%",
                    "art_coverage" = "%",
                    "incidence" = "",
                    "plhiv" = "",
                    "infections" = "",
                    "art_current" = "",
                    "art_current_residents" = "")

## This controls whether uncertainty range is shown
display_fmt <- c("prevalence" = "%s%s (%s-%s%s)",
                 "art_coverage" = "%s%s (%s-%s%s)",
                 "incidence" = "%s%s (%s-%s%s)",
                 "plhiv" = "%s%s (%s-%s%s)",
                 "infections" = "%s%s (%s-%s%s)",
                 "art_current_residents" = "%s%s (%s-%s%s)",
                 "art_current" = "%s%s")

indicators_15to49 <- c("prevalence", "incidence")
indicators_15plus <- c("art_coverage", "plhiv", "infections",
                       "art_current", "art_current_residents")


x1 <- data %>%
  sf::st_drop_geometry() %>%           
  dplyr::filter(
           sex == "both",
           age_group == "Y015_049" & indicator %in% indicators_15to49 |
           age_group == "Y015_999" & indicator %in% indicators_15plus
         ) %>%
  dplyr::left_join(
           sf::st_drop_geometry(outputs$meta_area) %>%
           dplyr::select(area_id, area_sort_order),
           by = "area_id"
         ) %>%
  dplyr::mutate(area_id = forcats::fct_reorder(area_id, area_sort_order)) %>%
  dplyr::select(area_id, area_name, mean, lower, upper, indicator)

## Format values
format_value <- function(x, indicator) {
  val <- round(x * display_scale[indicator], display_digits[indicator])
  mapply(format, val, trim = TRUE, scientific = FALSE,
         nsmall = pmax(display_digits[indicator], 0), big.mark = ",")
}

x1$mean <- format_value(x1$mean, x1$indicator)
x1$lower <- format_value(x1$lower, x1$indicator)
x1$upper <- format_value(x1$upper, x1$indicator)
x1$suffix <- display_suffix[x1$indicator]
x1$fmt <- display_fmt[x1$indicator]

x1$val <- sprintf(x1$fmt, x1$mean, x1$suffix, x1$lower, x1$upper, x1$suffix)

# Melt data in table 
x4 <- x1 %>% 
  dplyr::select(area_id, area_name, val, indicator) %>%
  tidyr::spread(indicator, val) %>%
  dplyr::select(
           area_name,
           plhiv,
           prevalence,
           infections,
           incidence,
           art_coverage,
           art_current_residents,
           art_current
         )

# #-------------------------------------------------------------------------------
# # Table: ART
# # # By lowest area_level, indicators defined above
# #------------------------------------------------------------------------------

x4 %>%
  gt::gt(rowname_col = "area_name") %>%
  gt::tab_stubhead(label = gt::md("**Area**")) %>%
  gt::tab_options(
    table.align = "left",
    heading.align = "centre",
    column_labels.font.size = "small",
    column_labels.background.color = "grey",
    table.font.size = "smaller",
    data_row.padding = gt::px(3),
  ) %>%
  gt::tab_spanner(
    label = gt::md("**Distribution of HIV**"),
    columns = gt::vars('plhiv', 'prevalence')) %>%
  gt::tab_spanner(
    label = gt::md("**Annual HIV infections**"),
    columns = gt::vars('incidence', 'infections')) %>%
  gt::tab_spanner(
    label = gt::md("**Antiretroviral Treatment**"),
    columns = gt::vars('art_coverage', 'art_current_residents', 'art_current')) %>%
  gt::cols_label(
    plhiv = gt::md("**PLHIV 15+**"),
    prevalence = gt::md("**HIV prevalence 15-49**"),
    infections = gt::md("**New infections 15+**"),
    incidence = gt::md("**Incidence 15-49 (per 1000)**"),
    art_coverage = gt::md("**ART coverage 15+**"),
    art_current = gt::md("**Number clients receiving ART 15+**"),
    art_current_residents = gt::md("**Number residents on ART 15+**")
  ) %>%
  gt::cols_align(align = "center") %>%
  gt::cols_width(everything()~ px(155))

```


### Methods

[Naomi](https://github.com/mrc-ide/naomi){target="_blank"} is a small-area estimation model for estimating HIV prevalence and PLHIV, ART coverage, and new HIV infections at district level by sex and five-year age group. The model combines district-level data about multiple outcomes from several sources in a Bayesian statistical model to produce robust indicators of subnational HIV burden.

The model produces estimates at three time points: the year of the most recent population-based survey, the current period at which the most recent ART and ANC programme data are available, and short-term one-year ahead projections for HIV programme planning purposes. Subnational population estimates by sex and age group are sourced from consensus sources in each country and adjusted to match the populations used within Spectrum by sex and age group.

_Survey data_

Cross-sectional estimates for HIV prevalence, ART coverage, and HIV incidence are produced at the mid-point of the most recent nationally representative household survey. For HIV prevalence, the model is calibrated to survey data about HIV prevalence by subnational level, sex, and five-year age group from the most recent population-based survey (for example [Population HIV Impact Assessment survey](https://phia.icap.columbia.edu/) or [Demographic and Health Survey](https://dhsprogram.com/)). Since the survey sample size in each district is relatively small, routinely reported data about HIV prevalence among pregnant women attending their first antenatal care visit, extracted from the national health information system, are used to improve estimates of the spatial pattern of HIV. 

_ART coverage_

Antiretroviral therapy coverage by district, age, and sex is estimated from household survey data about the presence of antiretroviral biomarkers in HIV-positive survey respondents. Routinely reported antiretroviral therapy coverage among pregnant women prior to first antenatal care visit is used as a covariate for the spatial pattern of antiretroviral therapy coverage. The antiretroviral therapy coverage and HIV prevalence are also calibrated so that total number on antiretroviral therapy matches that report in the Spectrum national file.  

```{r, echo = FALSE, results = 'asis'}
if("true" %in% include$art_attend) {
  
cat(paste0("
_ART attendance in neighbouring districts_\n 

A challenge for estimating treatment coverage at district level is that persons may access antiretroviral therapy services in a different district than their residence, for example if facilities are closer or perceived to provide better services. The model allows for a probability that resident people living with HIV access antiretroviral therapy in a neighbouring district. The prior assumption is that the large majority of people living with HIV will access antiretroviral therapy in their district of residence, but this probability can vary based on district data about the number receiving antiretroviral therapy compared to HIV prevalence, antiretroviral therapy coverage and population.
             
             
             "))
}
```

_HIV incidence_

Direct estimates of HIV incidence are not available at subnational levels. While some recent household surveys have measured HIV incidence at the national level based on biomarker measures for recent HIV infections, too few recent infections are observed in any district to make a robust estimate. Therefore, to estimate HIV incidence at the subnational level, the HIV transmission rate from Spectrum estimates is calculated and applied to small area estimates of HIV prevalence and ART coverage in each subnational area.  The sex and age distribution in each subnational area are based on HIV incidence rate ratios from Spectrum applied to the population structure in each area. 

_Current estimates and one-year ahead projection_

The update estimates from the most recent household survey to the current period, the model conducts a one-step projection of the population the most recent survey to the current period. Population estimates are updated with official population estimates. The number of PLHIV is projected forward based on survival estimates by province, sex, and age group from Spectrum over the same period (which accounts for HIV disease progression and effects of ART scale up on reducing AIDS mortality). ART coverage is updated based on the number currently reported on ART from service provision data.

To extrapolate estimates a further one-year ahead for HIV planning purposes, the number of new infections and PLHIV are calculated based on the transmission rate from national or subnational Spectrum estimates. The number on ART are projected by calculating the increased in odds of ART coverage by age and sex based on ART projections input to Spectrum and applying this change in odds to each subnational area.

_Version_

The Naomi model is supported by UNAIDS and developed and maintained by the [MRC Centre for Global Infectious Disease Analysis](https://www.imperial.ac.uk/mrc-global-infectious-disease-analysis) at Imperial College London. The model receives technical guidance from the [UNAIDS Reference Group on Estimates, Modelling, and Projections](http://epidem.org/). The model was first used in 2020 and continues to be developed responsive to new data and HIV strategic information needs.
